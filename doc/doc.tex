\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{palatino}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{natbib}
\bibliographystyle{abbrvnat}
\setcitestyle{authoryear}

\newcommand{\system}{\textsc{TypeWhich}\xspace}
\newcommand{\kw}[1]{\textbf{\texttt{#1}}}
\newcommand{\metavar}[1]{\textit{#1}}

\title{\system Guide}
\author{Luna Phipps-Costin, Carolyn Jane Anderson, Michael Greenberg, and Arjun Guha}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}

\system is a type migration tool for the gradually-typed lambda calculus and
the Grift programming language. Its distinguishing characteristics are the following:

\begin{enumerate}

\item \system formulates type migration as a MaxSMT problem.

\item \system always produces a migration, as long as the input program is
   well-scoped.

\item \system can optimize for different properties: it can produce the most
informative types, or types that ensure compatibility with un-migrated code.

\end{enumerate}

For more information on \system, see \citet{typewhich}.

\section{Building and Testing \system}

\subsection{Dependencies}

To build \system from source, you will need:

\begin{enumerate}

\item The \href{https://rustup.rs/}{Rust language toolchain}.

\item The Z3 build dependencies. On Ubuntu Linux, you can run the following
command to get them:

\begin{verbatim}
sudo apt-get install libz3-dev
\end{verbatim}

\item Python 3 and PyYAML to run the integration tests. These are installed by
   default on most platforms. If you can run the following command, then you
   already have them installed:
\begin{verbatim}
python3 -c "import yaml"
\end{verbatim}

\end{enumerate}

\subsection{Other Type Migration Tools}

The \system benchmarking suite is setup to compare \system to several other
type migration tools, some of these tools are in other repositories. You do not
need these other tools to use \system, but you do need them to reproduce the
evaluation from \citet{typewhich}.

\begin{enumerate}

\item \citet{rastogi:gti}: the \system code includes an implementation of this
algorithm, and it has no external dependencies.

\item \citet{migeed:decidable} is implemented in Haskell. We have written a
parser and printer for their tool that is compatible with \system. This
modified implementation is available at the following URL:

\url{https://github.com/arjunguha/migeed-palsberg-popl2020}

Build the tool as described in the repository, and then copy (or symlink) the
\texttt{MaxMigrate} program to \texttt{bin/MaxMigrate} in the \system directory..
On Linux, the executable is at:

\begin{verbatim}
migeed-palsberg-popl2020/.stack-work/install/x86_64-linux-tinfo6/
lts-13.25/8.6.5/bin/MaxMigrate
\end{verbatim}

\item \citet{siek:gti} is implemented in OCaml 3.12 (which is quite old).
The following repository has an implementation of the tool, with a modified
parser and printer that is compatible with \system:

\url{https://github.com/arjunguha/siek-vachharajani-dls2008}

Build the tool as described in the repository, and then copy (or symlink)
the \texttt{gtlc} program to \texttt{bin/gtubi} in the \system directory.

\textbf{Warning:} It is quite hard to build OCaml 3.12 on a modern Linux
system. The repository is configured to build a 32-bit Linux executable.

\item \citet{campora:migrating} [FILL]
   
   \url{https://github.com/arjunguha/mgt}

\end{enumerate}

\subsection{Building and Testing}

To build \system (and our implementation of \citet{rastogi:gti}), run the
following command:

\begin{verbatim}
cargo build
\end{verbatim}

Run the unit tests:

\begin{verbatim}
cargo test
\end{verbatim}

Test \system using the Grift benchmarks:

\begin{verbatim}
./test-runner.sh grift grift
\end{verbatim}

Finally, run the GTLC benchmarks without any third-party tools:

\begin{verbatim}
cargo run -- benchmark benchmarks.yaml \
  --ignore Gtubi MGT MaxMigrate > test.results.yaml
./bin/yamldiff test.expected.yaml test.results.yaml
\end{verbatim}

\section{Running \system}

The \system executable is symlinked to \texttt{bin/TypeWhich}. \system
expects its input program to be in a single file, and written in either
Grift (extension \texttt{.grift}) or in a superset of the 
gradually typed lambda calculus (extension \texttt{.gtlc}), shown in
Section~\ref{input-lang-gtlc}.

\paragraph{Example}
Create a file called \texttt{input.gtlc} with the following contents:

\begin{verbatim}
(fun f. (fun y. f) (f 5)) (fun x. 10 + x)
\end{verbatim}

This program omits all type annotations: \system assumes that omitted
annotations are all \kw{any}.

We can migrate the the program using \system in two modes:

\begin{enumerate}

\item In \emph{compatibility mode}, \system infers types but maintains
compatibility with un-migrated code:

\begin{verbatim}
$ ./bin/TypeWhich migrate input.gtlc
(fun f:any -> int. (fun y:int. f) (f 5)) (fun x:any. 10 + x)
\end{verbatim}

\item In \emph{precise mode}, \system infers the most precise type that it
can, though that may come at the expense of compatibility:

\begin{verbatim}
$ ./bin/TypeWhich migrate --unsafe inpuy.gtlc
(fun f:int -> int. (fun y:int. f) (f 5)) (fun x:int. 10 + x)
\end{verbatim}
     
\end{enumerate}

The \system executable supports several other sub-commands and flags. 
Run \texttt{./bin/TypeWhich --help} for more complete documentation.

\section{Input Language}\label{input-lang-gtlc}

\textbf{\url{./doc/doc.pdf} has the same content as this file, but with
slightly better formatting.}

\system supports a superset of the GTLC, written in the following syntax:

[FILL] A few cases missing

\begin{tabular}{rcll}
\metavar{b} & := & \kw{true} | \kw{false} & Boolean literal \\
\metavar{n} & := & ... | $-1$ | 0 | 1 | ... & Integer literals \\
\metavar{s} & := & \texttt{"..."} & String literals \\
\metavar{c} & := & b | n | s & Literals \\
\metavar{T} & := & \kw{any} & The unknown type \\
            & |  & \kw{int} & Integer type \\
            & |  & \kw{bool} & Boolean type \\
            & |  & \metavar{T}\textsubscript{1} \kw{->} \metavar{T}\textsubscript{2} & Function type \\
            & |  & \kw{(} \metavar{T} \kw{)} \\
\metavar{e} & := & \textit{x}  & Bound identifier \\
            & |  & \metavar{c} & Literal \\
            & |  & e \kw{:} T  & Type ascription \\
            & |  & \kw{(} \metavar{e} \kw{)} & Parenthesis \\
            & |  & \kw{fun} \metavar{x} \kw{.} \metavar{e} & Function \\
            & |  & \metavar{e}\textsubscript{1} \metavar{e}\textsubscript{2}
                 & Application \\
            & |  & \metavar{e}\textsubscript{1} \kw{+} \metavar{e}\textsubscript{2}
                 & Addition \\
            & |  & \metavar{e}\textsubscript{1} \kw{*} \metavar{e}\textsubscript{2}
                 & Multiplication \\
            & |  & \metavar{e}\textsubscript{1} \kw{=} \metavar{e}\textsubscript{2}
                 & Integer equality \\
            & |  & \metavar{e}\textsubscript{1} \kw{+?} \metavar{e}\textsubscript{2}
                 & Addition or string concatenation (overloaded) \\
            & |  & \kw{(}\metavar{e}\textsubscript{1}\kw{,}\metavar{e}\textsubscript{2}\kw{)}
                 & Pair \\
            & |  & \kw{fix} \metavar{f} \kw{.}\metavar{e}
                 & Fixpoint \\
            & |  & \kw{if} \metavar{e}\textsubscript{1} \kw{then} \metavar{e}\textsubscript{2} \kw{else} \metavar{e}\textsubscript{3}
                 & Conditional \\
            & |  & \kw{let} \metavar{x} \kw{=} \metavar{e}\textsubscript{1} \kw{in} \metavar{e}\textsubscript{2}
                 & Let binding \\
            & |  & \kw{let rec} \metavar{x} \kw{=} \metavar{e}\textsubscript{1} \kw{in} \metavar{e}\textsubscript{2}
                 & Recursive let binding \\

\end{tabular}

\section{Experiments}

\emph{To run the full suite of experiments, you will need to install the
third-party type migration tools.}

To run the experiments, use the following command:

\begin{verbatim}
./bin/TypeWhich benchmark benchmarks.yaml > RESULTS.yaml
\end{verbatim}

It prints progress on standard error. The output is a YAML file of results.

\subsection{Validation}

\begin{enumerate}

\item The benchmarking script does a lot of validation itself.

\item In \texttt{RESULTS.yaml}, look for the string ``Disaster''. It should not
appear!

\item In \texttt{RESULTS.yaml}, look for the string \verb|manually_verify|.
These are results from experiments where (1) we could not crash the migrated
program, and (2) the migrated program has fewer `any`s than the original. So,
the table of results counts this migration as one that is 100\% compatible with
untyped contexts. But, it requires a manual check.

\item Finally, you can compare \texttt{RESULTS.yaml} with a known good output
from benchmarking:

\begin{verbatim}
./bin/yamldiff RESULTS.yaml expected.yaml
\end{verbatim}

\end{enumerate}

\subsection{Results}

To generate the summary table found in \citet{typewhich}, use the following
command:
\begin{verbatim}
./bin/TypeWhich latex-benchmark-summary RESULTS.yaml 
\end{verbatim}

To generate the appendix of results:

\begin{verbatim}
./bin/TypeWhich latex-benchmarks RESULTS.yaml 
\end{verbatim}

\section{Benchmarks}

The \system repository has several benchmarks:

\begin{enumerate}
   
\item The \texttt{migeed} directory contains the benchmarks
from Migeed et al., written in the concrete syntax of \system.

\item The \texttt{adversarial} directory contains the ``challenge set'' from
the \system paper.

\item The \texttt{grift-suite} directory contains tests from
\href{https://github.com/Gradual-Typing/Grift/tree/master/tests/suite}{Grift}.
The
\texttt{mu/} directory has been modified to use Dyn where it originally used recursive
types.

\item The \texttt{grift-suite/benchmarks} contains benchmarks from
\url{https://github.com/Gradual-Typing/benchmarks} with the following
adjustments:

\begin{enumerate}
\item The getters and setters in n-body have been removed. They were neither used
nor exported we opted to remove these functions from the benchmark. This is
discussed in the paper.
\item We have changed where in the program some benchmarks print a terminating
newline for consistency between the static and dynamic versions.
\item Benchmarks that rely on modules are removed
\end{enumerate}
\end{enumerate}

\bibliography{doc}

\end{document}