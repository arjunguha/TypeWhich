---
tools:
  - title: TypeWhich
    command:
      - "./bin/TypeWhich"
      - migrate
      - "--unsafe"
  - title: TypeWhich2
    command:
      - "./bin/TypeWhich"
      - migrate
  - title: InsAndOuts
    command:
      - "./bin/TypeWhich"
      - migrate
      - "--ins-and-outs"
  - title: Gtubi
    command:
      - "./bin/gtubi"
  - title: MaxMigrate
    command:
      - "./bin/MaxMigrate"
  - title: MGT
    command:
      - "./bin/mgt"
benchmarks:
  - file: adversarial/01-farg-mismatch.gtlc
    results:
      Gtubi:
        result:
          Rejection:
            stdout: "adversarial/01-farg-mismatch.gtlc:1: bool and int are not consistent\n\n\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
      TypeWhich:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "(fun f:any -> int. f true) (fun x:any. x + 100)\n"
      MaxMigrate:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "(fun f : bool -> int . f true) (fun x : any . x + 100)\n"
      MGT:
        result:
          FullyCompatible:
            num_stars: 0
        migration: "(fun f : bool -> any. f true) (fun x : bool. ((x)) + ((100)))\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "(fun f:bool -> int. f true) (fun x:bool. (x : any) + 100)\n"
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 0
        migration: "(fun f:bool -> int. f true) (fun x:bool. x + 100)\n"
    num_stars: 2
  - file: adversarial/02-rank2-poly-id.gtlc
    results:
      MGT:
        result:
          Rejection:
            stdout: ""
            stderr: "[2021-04-14T14:41:49Z WARN  mgt] Untypable; unresolved type: bool.\n[2021-04-14T14:41:49Z WARN  mgt] (\\i : bool -> bool. (\\a : bool. i true) (i 5)) (\\x : bool. x)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 2
            manually_verify: true
        migration: "(fun i:any -> any. (fun a:any. i true) (i 5)) (fun x:any. x)\n"
      MaxMigrate:
        result: NewRuntimeError
        migration: "(fun i : any -> any . (fun a : int . i true) (i 5)) (fun x : bool . x)\n"
      InsAndOuts:
        expect_compatible: "(fun i:any -> any. (fun a:any. i true) (i 5)) (fun x:any. x)\n"
        result:
          FullyCompatible:
            num_stars: 2
        migration: "(fun i:any -> any. (fun a:any. i true) (i 5)) (fun x:any. x)\n"
      TypeWhich:
        expect_compatible: "(fun i:any -> any. (fun a:any. i true) (i 5)) (fun x:any. x)\n"
        result:
          FullyCompatible:
            num_stars: 2
        migration: "(fun i:any -> any. (fun a:any. i true) (i 5)) (fun x:any. x)\n"
      Gtubi:
        result:
          Rejection:
            stdout: "adversarial/02-rank2-poly-id.gtlc:1: bool and int are not consistent\n\n\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
    num_stars: 3
  - file: adversarial/03-unreachable-error.gtlc
    results:
      MaxMigrate:
        result:
          Rejection:
            stdout: ""
            stderr: "MaxMigrate: Maybe.fromJust: Nothing\n"
      TypeWhich:
        expect_compatible: "(fun b:(any -> any) -> (any -> int) -> any -> int. b (fun c:any.\n  (fun x:any. x x) 5 5) (fun d:any. 0)) (fun t:any -> any.\nfun f:any -> int. f)"
        result:
          FullyCompatible:
            num_stars: 3
        migration: "(fun b:(any -> any) -> (any -> int) -> any -> int. b (fun c:any.\n  (fun x:any. x x) 5 5) (fun d:any. 0)) (fun t:any -> any.\nfun f:any -> int. f)\n"
      MGT:
        result:
          Rejection:
            stdout: ""
            stderr: "[2021-04-14T14:41:54Z WARN  mgt] Untypable; unresolved type: a15 -> int.\n[2021-04-14T14:41:54Z WARN  mgt] (\\b : (a1 -> a10) -> (a15 -> int) -> a15 -> int.\n    b (\\c : a1. (\\x : a5 -> int -> a10. x x) 5 5) (\\d : a15. 0))\n    (\\t : a1 -> a10. \\f : a15 -> int. f)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 3
            manually_verify: true
        migration: "(fun b:(any -> any) -> (any -> int) -> any -> int. b (fun c:any.\n  (fun x:any. x x) 5 5) (fun d:any. 0)) (fun t:any -> any.\nfun f:any -> int. f)\n"
      InsAndOuts:
        expect_compatible: "(fun b:(⦉4418⦊ -> ⦉4418⦊) -> (any -> int) -> any -> int. b\n  (fun c . (fun x:int. x x) 5 5) (fun d:any. 0))\n(fun t:⦉4418⦊ -> ⦉4418⦊. fun f:any -> int. f)\n"
        result:
          FullyCompatible:
            num_stars: 2
        migration: "(fun b:(⦉4418⦊ -> ⦉4418⦊) -> (any -> int) -> any -> int. b\n  (fun c . (fun x:int. x x) 5 5) (fun d:any. 0))\n(fun t:⦉4418⦊ -> ⦉4418⦊. fun f:any -> int. f)\n"
      Gtubi:
        result:
          Rejection:
            stdout: ""
            stderr: "Fatal error: exception Stack_overflow\n"
    num_stars: 6
  - file: adversarial/04-f-in-f-out.gtlc
    results:
      InsAndOuts:
        expect_compatible: "(fun f:any -> int. (fun y:int. f) (f 5)) (fun x:any. 10 + x)\n"
        result:
          FullyCompatible:
            num_stars: 1
        migration: "(fun f:any -> int. (fun y:int. f) (f 5)) (fun x:any. 10 + x)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 1
            manually_verify: true
        migration: "(fun f:any -> int. (fun y:int. f) (f 5)) (fun x:any. 10 + x)\n"
      MaxMigrate:
        result: NewRuntimeError
        migration: "(fun f : int -> any . (fun y : bool . f) (f 5)) (fun x : int . 10 + x)\n"
      MGT:
        result:
          FullyCompatible:
            num_stars: 0
            manually_verify: true
        migration: "(fun f : int -> int. (fun y : int. f) (f 5)) (fun x : int. 10 + x)\n"
      Gtubi:
        expect_compatible: "((fun f : (int -> int). ((fun y : int. f) (f 5))) (fun x : int. (10 + x)))"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "((fun f : (int -> int). ((fun y : int. f) (f 5))) (fun x : int. (10 + x)))"
      TypeWhich:
        expect_compatible: "(fun f:int -> int. (fun y:int. f) (f 5)) (fun x:int. 10 + x)\n"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "(fun f:int -> int. (fun y:int. f) (f 5)) (fun x:int. 10 + x)\n"
    num_stars: 3
  - file: adversarial/05-order3-fun.gtlc
    context: "(HOLE) (fun a . a) (fun b . true)\n"
    results:
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 2
        migration: "fun f:any. fun x:any. x (f x)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 2
        migration: "fun f:any. fun x:any. x (f x)\n"
      TypeWhich:
        expect_compatible: "fun f:(any -> any) -> any. fun x:any -> any. x (f x)\n"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "fun f:(any -> any) -> any. fun x:any -> any. x (f x)\n"
      MGT:
        result:
          FullyCompatible:
            num_stars: 0
            manually_verify: true
        migration: "fun f : (any -> any) -> any. fun x : any -> any. x (f x)\n"
      MaxMigrate:
        result:
          Restricted:
            num_stars: 1
        migration: "fun f : int -> int . fun x : any . x (f x)\n"
      Gtubi:
        expect_compatible: "(fun f : ((beta@1 -> beta@2) -> beta@1). (fun x : (beta@1 -> beta@2). (x (f x))))"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "(fun f : ((beta@1 -> beta@2) -> beta@1). (fun x : (beta@1 -> beta@2). (x (f x))))"
    num_stars: 2
  - file: adversarial/06-order3-intfun.gtlc
    context: "(HOLE) (fun a . fun b . true) (fun c . 0)\n"
    results:
      Gtubi:
        result:
          FullyCompatible:
            num_stars: 0
            manually_verify: true
        migration: "(fun f : ((int -> int) -> (int -> beta@5)). (fun g : (int -> int). ((f g) ((g 10) + 1))))"
      MaxMigrate:
        result:
          Restricted:
            num_stars: 1
        migration: "fun f : int -> int -> int . fun g : any . f g (g 10 + 1)\n"
      MGT:
        result:
          FullyCompatible:
            num_stars: 0
            manually_verify: true
        migration: "fun f : (int -> int) -> int -> any. fun g : int -> int. f g ((g 10) + 1)\n"
      TypeWhich:
        result:
          Restricted:
            num_stars: 0
        migration: "fun f:(int -> int) -> int -> int. fun g:int -> int. f g (g 10 + 1)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 2
        migration: "fun f:any. fun g:any. f g (g 10 + 1)\n"
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 2
        migration: "fun f:any. fun g:any. f g (g 10 + 1)\n"
    num_stars: 2
  - file: adversarial/07-double-f.gtlc
    context: "(HOLE) (fun x . fun y . y)\n"
    results:
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun f:any. f (f true)\n"
      MaxMigrate:
        result:
          Restricted:
            num_stars: 0
        migration: "fun f : any -> int . f (f true)\n"
      MGT:
        result:
          Restricted:
            num_stars: 0
        migration: "fun f : bool -> bool. f (f true)\n"
      TypeWhich:
        result:
          Restricted:
            num_stars: 0
        migration: "fun f:bool -> bool. f (f true)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun f:any. f (f true)\n"
      Gtubi:
        result:
          Restricted:
            num_stars: 0
        migration: "(fun f : (bool -> bool). (f (f true)))"
    num_stars: 1
  - file: adversarial/08-outflows.gtlc
    results:
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 0
        migration: "(fun x:int. x 5 + x) 5\n"
      TypeWhich:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "(fun x:int. (x : any) 5 + x) 5\n"
      MaxMigrate:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "(fun x : any . x 5 + x) 5\n"
      MGT:
        result:
          Rejection:
            stdout: ""
            stderr: "[2021-04-14T14:41:56Z WARN  mgt] Untypable; unresolved type: d1R<d0R<?,int>,string>.\n[2021-04-14T14:41:56Z WARN  mgt] (\\x : int -> d1R<d0R<a5,int>,string>. (x 5) d1R<d0R<+, +>, +> x) 5\n"
      Gtubi:
        result:
          Rejection:
            stdout: "<Unknown file and line>:  int and (int -> beta@3_{11}) are not consistent\n\n\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "(fun x:int. (x : any) 5 + x) 5\n"
    num_stars: 1
  - file: adversarial/09-precision-relation.gtlc
    results:
      InsAndOuts:
        expect_compatible: "(fun f:any -> int. f true + (fun g:int -> int. g 5) f) (fun x:any. 5)\n"
        result:
          FullyCompatible:
            num_stars: 1
        migration: "(fun f:any -> int. f true + (fun g:int -> int. g 5) f) (fun x:any. 5)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 1
            manually_verify: true
        migration: "(fun f:any -> int. f true + (fun g:any -> int. g 5) f) (fun x:any. 5)\n"
      MGT:
        result:
          Rejection:
            stdout: ""
            stderr: "[2021-04-14T14:41:57Z WARN  mgt] Untypable; unresolved type: d1R<d0R<?,int>,string>.\n[2021-04-14T14:41:57Z WARN  mgt] (\\f : bool -> d1R<d0R<int,int>,string>.\n    (f true) d1R<d0R<+, +>, +> ((\\g : int -> d1R<d0R<int,int>,string>. g 5) f))\n    (\\x : bool. 5)\n"
      TypeWhich:
        expect_compatible: "(fun f:any -> int. f true + (fun g:any -> int. g 5) f) (fun x:any. 5)\n"
        result:
          FullyCompatible:
            num_stars: 1
        migration: "(fun f:any -> int. f true + (fun g:any -> int. g 5) f) (fun x:any. 5)\n"
      Gtubi:
        result:
          Rejection:
            stdout: "<Unknown file and line>:  int and bool are not consistent\n\n\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
      MaxMigrate:
        result: NewRuntimeError
        migration: "(fun f : bool -> int . f true + (fun g : any -> int . g 5) f) (fun x : bool . 5)\n"
    num_stars: 3
  - file: adversarial/10-if-tag.gtlc
    context: "(HOLE) true 1\n"
    results:
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 2
        migration: "fun tag:any. fun x:any. if tag then x + 1 else if x then 1 else 0\n"
      InsAndOuts:
        result:
          Rejection:
            stdout: ""
            stderr: "thread 'main' panicked at 'PANIC_ON_MISMATCH = true: Err(\"expected bool got any\")', src/type_check.rs:296:13\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
      Gtubi:
        result:
          Rejection:
            stdout: "adversarial/10-if-tag.gtlc:1: Undefined variable if\n\n\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
      TypeWhich:
        result:
          Restricted:
            num_stars: 1
        migration: "fun tag:bool. fun x:bool. if tag\n    then (x : any) + 1\n    else if x then 1 else 0\n"
      MaxMigrate:
        result:
          Rejection:
            stdout: ""
            stderr: "MaxMigrate: Maybe.fromJust: Nothing\n"
      MGT:
        result:
          Restricted:
            num_stars: 0
        migration: "fun tag : bool.\nfun x : bool. if tag then (((x)) + ((1))) else if x then 1 else 0\n"
    num_stars: 2
  - file: migeed/01_apply_add.gtlc
    results:
      MaxMigrate:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x : any . x (x + 1)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any. x (x + 1)\n"
      TypeWhich:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any -> any. x ((x : any) + 1)\n"
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any. x (x + 1)\n"
      Gtubi:
        result:
          Rejection:
            stdout: ""
            stderr: "Fatal error: exception Stack_overflow\n"
      MGT:
        result:
          FullyCompatible:
            num_stars: 0
            manually_verify: true
        migration: "fun x : any -> any. x (((x)) + ((1)))\n"
    num_stars: 1
  - file: migeed/02_add_applied.gtlc
    context: "(HOLE) (fun y . 1)\n"
    results:
      MaxMigrate:
        expect_compatible: "fun x : any -> int . x (x true + 1)\n"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "fun x : any -> int . x (x true + 1)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any. x (x true + 1)\n"
      Gtubi:
        result:
          Rejection:
            stdout: "migeed/02_add_applied.gtlc:1: bool and int are not consistent\n\n\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
      TypeWhich:
        expect_compatible: "fun x:any -> int. x (x true + 1)\n"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "fun x:any -> int. x (x true + 1)\n"
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any. x (x true + 1)\n"
      MGT:
        result:
          Restricted:
            num_stars: 0
        migration: "fun x : bool -> any. x (((x true) + ((1))))\n"
    num_stars: 1
  - file: migeed/03_add_two_applies.gtlc
    context: "(HOLE) (fun y . 1)\n"
    results:
      TypeWhich:
        expect_compatible: "fun x:any -> int. x 4 + x true\n"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "fun x:any -> int. x 4 + x true\n"
      MaxMigrate:
        expect_compatible: "fun x : any -> int . x 4 + x true\n"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "fun x : any -> int . x 4 + x true\n"
      Gtubi:
        result:
          Rejection:
            stdout: "<Unknown file and line>:  int and (int -> beta@3_{11}) are not consistent\n\n\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any. x 4 + x true\n"
      MGT:
        result:
          Rejection:
            stdout: ""
            stderr: "[2021-04-14T14:41:59Z WARN  mgt] Untypable; unresolved type: (int -> d1R<d0R<a9,int>,string>) -> d1R<d0R<?,int>,string>.\n[2021-04-14T14:41:59Z WARN  mgt] \\x : int -> d1R<d0R<a9,int>,string>. (x 4) d1R<d0R<+, +>, +> (x true)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any. x 4 + x true\n"
    num_stars: 1
  - file: migeed/04_identity_four.gtlc
    results:
      MaxMigrate:
        expect_compatible: "(fun x : int . x) 4\n"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "(fun x : int . x) 4\n"
      Gtubi:
        expect_compatible: "((fun x:int. x) 4)\n"
        result:
          FullyCompatible:
            num_stars: 0
            manually_verify: true
        migration: "((fun x : int. x) 4)"
      InsAndOuts:
        expect_compatible: "(fun x:int. x) 4\n"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "(fun x:int. x) 4\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 0
            manually_verify: true
        migration: "(fun x:int. x) 4\n"
      TypeWhich:
        expect_compatible: "(fun x:int. x) 4\n"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "(fun x:int. x) 4\n"
      MGT:
        result:
          FullyCompatible:
            num_stars: 0
            manually_verify: true
        migration: "(fun x : int. x) 4\n"
    num_stars: 1
  - file: migeed/05_succ_id_id.gtlc
    results:
      MGT:
        result:
          FullyCompatible:
            num_stars: 0
        migration: "((1)) + (((fun y : bool. y) ((fun x : bool. x) true)))\n"
      MaxMigrate:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "1 + (fun y : int . y) ((fun x : any . x) true)\n"
      TypeWhich:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "1 + (fun y:bool. (y : any)) ((fun x:bool. x) true)\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 0
        migration: "1 + (fun y:bool. y) ((fun x:bool. x) true)\n"
      Gtubi:
        result:
          Rejection:
            stdout: "<Unknown file and line>:  int and bool are not consistent\n\n\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 0
        migration: "1 + (fun y:bool. y) ((fun x:bool. x) true)\n"
    num_stars: 2
  - file: migeed/06_identity.gtlc
    context: "(HOLE) (fun y . y)\n"
    results:
      MGT:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x : any. x\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any. x\n"
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any. x\n"
      TypeWhich:
        result:
          Restricted:
            num_stars: 0
        migration: "fun x:int. x\n"
      Gtubi:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "(fun x : _t0. x)"
      MaxMigrate:
        result:
          Restricted:
            num_stars: 0
        migration: "fun x : int . x\n"
    num_stars: 1
  - file: migeed/07_apply2.gtlc
    context: "(HOLE) 1 (fun z1 . fun z2 . 1)\n"
    results:
      MGT:
        result:
          FullyCompatible:
            num_stars: 1
            manually_verify: true
        migration: "fun x : any. fun y : any -> any -> any. y x x\n"
      Gtubi:
        expect_compatible: "(fun x : _t1. (fun y : (_t1 -> (_t1 -> beta@2)). ((y x) x)))\n"
        result:
          FullyCompatible:
            num_stars: 1
        migration: "(fun x : _t1. (fun y : (_t1 -> (_t1 -> beta@2)). ((y x) x)))"
      TypeWhich:
        expect_compatible: "fun x:any. fun y:any -> any -> any. y x x\n"
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any. fun y:any -> any -> any. y x x\n"
      MaxMigrate:
        assert_unusable: true
        result: Unusable
        migration: "fun x : any . fun y : int -> bool -> int . y x x\n"
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 2
        migration: "fun x:any. fun y:any. y x x\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 2
        migration: "fun x:any. fun y:any. y x x\n"
    num_stars: 2
  - file: migeed/08_indirect_apply_self.gtlc
    context: "(HOLE) (fun z : any . z)\n"
    results:
      MaxMigrate:
        assert_unusable: true
        result: Unusable
        migration: "fun x : any . (fun y : int . x) x x\n"
      Gtubi:
        result:
          Rejection:
            stdout: "there is a cycle, no solution\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
      TypeWhich:
        expect_compatible: "fun x:any -> any. (fun y:any -> any. x) x x\n"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "fun x:any -> any. (fun y:any -> any. x) x x\n"
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 2
        migration: "fun x:any. (fun y:any. x) x x\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 2
        migration: "fun x:any. (fun y:any. x) x x\n"
      MGT:
        result:
          Rejection:
            stdout: ""
            stderr: "[2021-04-14T14:42:01Z WARN  mgt] Untypable; unresolved type: (a4 -> a5) -> a5.\n[2021-04-14T14:42:01Z WARN  mgt] \\x : a4 -> a5. (\\y : a4 -> a5. x) x x\n"
    num_stars: 2
  - file: migeed/09_the_long_one.gtlc
    results:
      MGT:
        result:
          FullyCompatible:
            num_stars: 2
            manually_verify: true
        migration: "fun x : any.\n(fun f : any -> int. (fun xx : any -> int. fun y : int. xx) f (f x))\n  (fun z : any. 1)\n"
      TypeWhich:
        result:
          FullyCompatible:
            num_stars: 2
            manually_verify: true
        migration: "fun x:any. (fun f:any -> int. (fun xx:any -> int. fun y:int. xx) f (f\n    x)) (fun z:any. 1)\n"
      InsAndOuts:
        expect_compatible: "fun x:any. (fun f:any -> int. (fun xx:any -> int. fun y:int. xx) f (f x))\\n  (fun z:any. 1)\n"
        result:
          FullyCompatible:
            num_stars: 2
            manually_verify: true
        migration: "fun x:any. (fun f:any -> int. (fun xx:any -> int. fun y:int. xx) f (f\n    x)) (fun z:any. 1)\n"
      MaxMigrate:
        result:
          FullyCompatible:
            num_stars: 1
            manually_verify: true
        migration: "fun x : int . (fun f : any . (fun xx : int . fun y : int . xx) f (f x)) (fun z : int . 1)\n"
      Gtubi:
        expect_compatible: "(fun x : _t3. ((fun f : (_t3 -> int). (((fun xx : (_t3 -> int). (fun y : int. xx)) f) (f x))) (fun z : _t3. 1)))\n"
        result:
          FullyCompatible:
            num_stars: 2
        migration: "(fun x : _t3. ((fun f : (_t3 -> int). (((fun xx : (_t3 -> int). (fun y : int. xx)) f) (f x))) (fun z : _t3. 1)))"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 2
            manually_verify: true
        migration: "fun x:any. (fun f:any -> int. (fun xx:any -> int. fun y:int. xx) f (f\n    x)) (fun z:any. 1)\n"
    num_stars: 5
  - file: migeed/10_apply_self.gtlc
    results:
      TypeWhich:
        expect_compatible: "fun x:any -> any. x x\n"
        result:
          FullyCompatible:
            num_stars: 0
        migration: "fun x:any -> any. x x\n"
      Gtubi:
        result:
          Rejection:
            stdout: "there is a cycle, no solution\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
      MaxMigrate:
        result:
          Rejection:
            stdout: ""
            stderr: "MaxMigrate: Maybe.fromJust: Nothing\n"
      MGT:
        result:
          Rejection:
            stdout: ""
            stderr: "[2021-04-14T14:42:01Z WARN  mgt] Untypable; unresolved type: (a3 -> a4) -> a4.\n[2021-04-14T14:42:01Z WARN  mgt] \\x : a3 -> a4. x x\n"
      InsAndOuts:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any. x x\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 1
        migration: "fun x:any. x x\n"
    num_stars: 1
  - file: migeed/11_untypable_in_sys_f.gtlc
    results:
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 4
            manually_verify: true
        migration: "(fun x:(any -> any) -> any. fun y:any. y (x (fun x:any. x)) (x\n    (fun b:any. fun c:any. b))) (fun d:any -> any. d d)\n"
      MaxMigrate:
        result:
          Rejection:
            stdout: ""
            stderr: "MaxMigrate: Maybe.fromJust: Nothing\n"
      MGT:
        result:
          Rejection:
            stdout: ""
            stderr: "[2021-04-14T14:42:38Z WARN  mgt] Untypable; unresolved type: (a25 -> a25 -> a20) -> a20.\n[2021-04-14T14:42:38Z WARN  mgt] (\\x : (a25 -> a25) -> a25.\n    \\y : a25 -> a25 -> a20. y (x (\\x : a25. x)) (x (\\b : a25. \\c : a12. b)))\n    (\\d : a25 -> a25. d d)\n"
      InsAndOuts:
        result:
          Rejection:
            stdout: ""
            stderr: ""
      TypeWhich:
        result:
          FullyCompatible:
            num_stars: 3
            manually_verify: true
        migration: "(fun x:(any -> any) -> any. fun y:any -> any -> any. y (x (fun x:any.\n    x)) (x (fun b:any. fun c:any. b))) (fun d:any -> any. d d)\n"
      Gtubi:
        result:
          Rejection:
            stdout: "there is a cycle, no solution\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
    num_stars: 6
  - file: migeed/12_self_interpreter.gtlc
    results:
      MaxMigrate:
        result:
          Rejection:
            stdout: ""
            stderr: ""
      MGT:
        result:
          Rejection:
            stdout: ""
            stderr: "[2021-04-14T14:43:39Z WARN  mgt] Untypable; unresolved type: ((a21 -> a21) -> ((a21 -> a21) -> (a21 -> a21) -> a39) -> a39) ->\n    (a21 -> a21) -> ((a21 -> a21) -> (a21 -> a21) -> a39) -> a39.\n[2021-04-14T14:43:39Z WARN  mgt] (\\h : ((a21 -> a21) -> ((a21 -> a21) -> (a21 -> a21) -> a39) -> a39) ->\n    ((a21 -> a21) -> ((a21 -> a21) -> (a21 -> a21) -> a39) -> a39) ->\n    (a21 -> a21) -> ((a21 -> a21) -> (a21 -> a21) -> a39) -> a39.\n    (\\x : ((a21 -> a21) -> ((a21 -> a21) -> (a21 -> a21) -> a39) -> a39) ->\n      (a21 -> a21) -> ((a21 -> a21) -> (a21 -> a21) -> a39) -> a39.\n      h (x x))\n      (\\x : (a21 -> a21) -> ((a21 -> a21) -> (a21 -> a21) -> a39) -> a39. h x x))\n    (\\e : (a21 -> a21) -> ((a21 -> a21) -> (a21 -> a21) -> a39) -> a39.\n      \\m : (a21 -> a21) ->\n        ((a21 -> a21) -> (a21 -> a21) -> a39) ->\n        ((a45 -> a21 -> a21) ->\n        a45 -> ((a21 -> a21) -> (a21 -> a21) -> a39) -> a39) ->\n        (a21 -> a21) -> ((a21 -> a21) -> (a21 -> a21) -> a39) -> a39.\n        m (\\x : a21. x) (\\m : a21 -> a21. \\n : a21 -> a21. e m (e n))\n          (\\m : a45 -> a21 -> a21. \\v : a45. e (m v)))\n"
      TypeWhich2:
        result:
          FullyCompatible:
            num_stars: 8
            manually_verify: true
        migration: "(fun h:any -> any -> any. (fun x:any -> any. h (x x)) (fun x:any. h x\n    x)) (fun e:any. fun m:any. m (fun x:any. x) (fun m:any. fun n:any. e\n        m (e n)) (fun m:any. fun v:any. e (m v)))\n"
      InsAndOuts:
        result:
          Rejection:
            stdout: ""
            stderr: ""
      TypeWhich:
        result:
          FullyCompatible:
            num_stars: 8
            manually_verify: true
        migration: "(fun h:any -> any -> any. (fun x:any -> any. h (x x)) (fun x:any. h x\n    x)) (fun e:any. fun m:any. m (fun x:any. x) (fun m:any. fun n:any. e\n        m (e n)) (fun m:any. fun v:any. e (m v)))\n"
      Gtubi:
        result:
          Rejection:
            stdout: "there is a cycle, no solution\n"
            stderr: "Fatal error: exception Support.Error.Exit(1)\n"
    num_stars: 10

TypeWhich & 0 / 22 & 0 / 22 & 0 / 22 &  4 / 22 & 25 / 58 \\ 
TypeWhich2 & 0 / 22 & 0 / 22 & 0 / 22 &  0 / 22 & 39 / 58 \\ 
InsAndOuts & 3 / 22 & 0 / 19 & 0 / 19 &  0 / 19 & 22 / 40 \\ 
Gtubi & 14 / 22 & 0 / 8 & 0 / 8 &  1 / 8 & 4 / 17 \\ 
MaxMigrate & 5 / 22 & 3 / 17 & 2 / 14 &  4 / 12 & 7 / 20 \\ 
MGT & 9 / 22 & 0 / 13 & 0 / 13 &  3 / 13 & 4 / 25 \\ 
